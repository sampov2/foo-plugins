\documentclass[11pt,a4paper]{article}
\usepackage{lac2010}
\usepackage{amssymb,amsmath}

\sloppy
\newenvironment{contentsmall}{\small}

\title{Faust in Action}

%see lac2010.sty for how to format multiple authors!
\author
{Sampo Savolainen % SAVOLAINEN?
\\ Foo-plugins
\\ http://foo-plugins.googlecode.com/
\\ sampo.savolainen@gmail.com
}

\begin{document}
\maketitle


\begin{abstract}
\begin{contentsmall}
This paper describes the working principles of a 40 year old transistor organ and how it is emulated with software. The emulation presented in this paper is open source and written in a functional language called Faust. The architecture of the organ proved to be challenging for Faust, thus the process of writing this emulation highlighted some of Faust's strengths and shortcomings.

\end{contentsmall}
\end{abstract}

\keywords{
\begin{contentsmall}
Faust, LV2, DSP, emulation
\end{contentsmall}
}

\section{Introduction}

Faust\cite{orlarey:09c} stands for Functional AUdio STream and as the name implies it is a functional language designed for audio processing. The Faust compiler is an intermediary compiler, which produces a C++ class which is integrated into a chosen C++ "architecture". This architecture file provides a run-time environment, or wrapper, for the processing. This wrapper can be a stand-alone Linux Jack application, a LADSPA plugin or a VST plugin.

%% TODO choose license
This paper describes how an emulation of a 1970's combo-organ was written in Faust. The Yamaha YC-20 is a fairly typical organ of its time, a transistor based relatively light instrument meant for gigging musicians. The organ can be classified as a paraphonic synthesizer. Its working principles are discussed in detail in section \ref{section:yc-20}. The emulation is written as open source as GPLv3. In the spirit of open source, the working principles and decisions taken during writing the emulation are described in this paper for all to read.

The YC-20 was chosen to be emulated as its architecture is very different from typical software and virtual analog synthesizers. Instead of the complex controllability and routability of typical synthesizers, the paraphonic organ requires a large number of parallel processes and components. This makes for a good test of Fausts performance and parallelization capabilities. Access to an operational organ was also a factor in the choice, as it made possible to match the emulation quality against the original. 

\section{YC-20}
\label{section:yc-20}

This section covers the operations of the organ in detail\cite{yamaha:yc20}. This is section is later referred to when discussing the emulated parts.

\subsection{Features}

The organ has one physical manual with 61 keys and two sound sections and a switchable bass manual. Instead of drawbars like Hammond organs, the sounds are controlled by a lever system used in Yamaha organs of the time. As the word drawbar is commonplace when discussing organ sounds, I use it instead of lever. Each of the drawbar lever in the organ have four positions from off to full volume. 

Section I has drawbars 16', 8', 4', 2-2/3', 2', 1-3/5' and 1' and section II has drawbars 16', 8', 4', 2' and a continuous brightness lever. The sections can be selected or mixed together using a continuous balance lever. Enabling the bass manual switches the lowest 17 keys (white on black) to bass sounds with drawbars 16' and 8'. There are also controls for pitch, volume, bass volume, vibrato depth, vibrato speed and an obscure "touch vibrato" feature. The organ also has a single global percussion drawbar and an integrated volume pedal. Like the drawbars, all vibrato controls have four positions.

% the style of controls? .. probably irrelevant
\subsection{Tone generation}

The synthesizer architecture comprises of 12 oscillators, one per each note on an octave. For each oscillator, there are 7 frequency divider stages so each oscillator produces 8 voices totalling 96 voices. These voices are then fed through a passive filter bank. The divided voices have both a high pass and low pass filters while the oscillator voices have only a high pass filter. This totals 180 resistor-capacitor networks. Filtered voices are connected to switches controlled by the keyboard. The keyboard is in fact a matrix mixer connecting the voices to bus bars. Keys feed each bus bar with the appropriate voice matching that key and octave or the matching harmonic voice for the 2-2/3' and 1-3/5' drawbars. 

\subsection{Sections}
\label{section:sections}

The drawbars are potentiometers which control how much of each bus bar is mixed the sections of the organ. While in section I, drawbars are simply mixed together, Section II drawbars have more complex filtering. Each section II drawbar is divided into two streams, each filtered separately with rc networks. One stream is low pass filtered with two stages while the other has two stages of high pass filtering. The low passed and high passed signals from different drawbars are then combined and buffered. The brightness potentiometer controls a mix of the two which, after further buffering, is the output of section II. 

The switches on the lowest 17 keys feed either the main bus bars or separate bass bus bars. This is controlled by the bass manual switch. When disabled, the bass bus bars contain no signal. When enabled, the bass keys have no effect on the main bus bars.

Bass manual differs from the two main sections in that both bass manual drawbars (16' and 8') contain a mix of multiple bass bus bars. The 16' drawbar contains a mix of all three bass bus bars, with the 16' bass bus bar mixed with the lowest value resistor and the 4' bass bus bar with the highest value resistor. The 8' drawbar is a mix of the 8' bass bus bar with a lower value resistor and 4' bass bus bar with a higher value resistor. While section I and section II drawbar control potentiometers are wired in a standard volume configuration, the bass manual drawbars are wired center-tap to source. This configuration makes the drawbar control not only affect how much of the drawbar is mixed in, but it varies the impedance of the signal. The varying impedance and capacitor after summing the drawbar signals makes the network into a fairly complex rc filter with a varying cutoff point and mix amount per bass bus bar.

\subsection{Percussion}

% Still a bit iffy
Percussion manual sounds are created by mixing together bus bars 1', 2-2/3' and 16' via resistors. There is a substantially larger resistor on the 1' bus bar. This sum is then ran through a VCA controlled by a simple envelope generator. This envelope generator is triggered by activity on the 1' bus bar. The envelope attack and release timings are very fast while the sustain level is near zero. This causes a fast attack sound, but the effect only works when no keys are pressed down before. In other words, the percussion effect is not heard, for example, when playing legato. However there is a substantial amount of bleed from the percussion section which is audible when all other drawbars are off.

% As the bass manual switch disengages bass keys from the main bus bars

\subsection{Main output}

The main output of the device is a mix of sections I and II, the percussion part and the bass manual. The mix between sectioions I and II is controlled by the balance potentiometer. The amount of percussion mixed in is controlled by the percussion drawbar. Bass manual is summed into the main output via a potentiometer controlling its volume. This main output is preamplified and then can be attenuated by both the main volume potentiometer of the device and the volume pedal. The volume pedla works by a mechanical shutter and a light dependent resistor.

\section{The emulation} 

I chose Faust to emulate the organ as the organ is effectively an "always on" design. Unlike with polyphonic synthesizers, all possible voices of the organ are always running. There is a large amount of streams transferred between the circuits and Faust's modus operandi fits this design well. The emulation tries not only to emulate the ideal circuit but also some of the inaccuracies and issues caused in the real instrument. 

The emphasis was on creating a playable instrument which sounds as close to the original as possible. A playable emulation needs to be able to work at low latencies and it needs to be efficient enough to be ran on fairly typical hardware.

\subsection{Tone generation}

The 12 oscillators are sawtooth oscillators with a varying bias voltage (see section \ref{section:oscillator-bias}). The main oscillator sounds are divided by an array of flip flops each dividing the frequency by half. The flip flops naturally produce square waves. This means each oscillator creates 8 phase-synchronized voices.

As the main oscillator frequencies are high (4--8kHz), a naive oscillator implementation would suffer massively from aliasing at typical sampling rates (44.1--96kHz). Naturally, also the dividers need to be band-limited as well. I evaluated different methods to band-limit the signals and chose the PolyBLEP\cite{antialiasing} method. While BLEP\cite{hardsync} would produce a less aliasing harmonics, it is computationally more expensive. More importantly, the BLEP response is currently impossible to calculate in Faust as it requires DFT and inverse-DFT functions. The quality of BLIT-SWS\cite{blit} is good at high frequencies, but it produces sub-harmonics\cite{antialiasing}. Also, BLIT-SWS is problematic when it comes to synchronized oscillators\cite{hardsync}.

I evaluated second, third and fourth order polynomial functions for the PolyBLEP. The higher order residual functions reduced high frequency aliasing only slightly compared to the second order function. Furthermore the second order function did not create the sub-harmonics the third and fourth order functions caused. This confirmed previous findings\cite{pekonen}. The chosen second order polynomial residual function \emph{r(t)} is shown as equation \ref{eq:polyblep}.

\begin{equation}
\label{eq:polyblep}
r(t) = \begin{cases} 	t^2/2  + t + 1/2, & \mbox{if } -1 \leq t \leq 0\\ 
			-t^2/2 + t - 1/2, & \mbox{if } 0 < t \leq 1 \end{cases}
\end{equation}

The divider circuits emulated as slaved oscillators. The main oscillator function outputs both the signal and phase information. One divisor function divides the phase and feeds this to a slave oscillator. The slave again produces both a signal and phase information. The divider circuit for one oscillator is seven such divisor functions piggybacked.

PolyBLEP works by adding the polynomial band-limited step function to two samples: the sample before and after a discontinuity in the signal. To achieve this, the Faust implementation delays its output by one sample. At each frame, the phase is inspected and if it has passed a discontinuity, the PolyBLEP function is calculated and added (rising wave) or subtracted (falling wave) for the previous sample and the current sample. As Faust lacks true branches, all possible branches of conditional statements are always calculated. Table \ref{table:polyblep-amount} shows that branching would allow an efficient solution. This is because without branching the amount of PolyBLEP evaluations is purely a function of the sampling rate while the amount of required evaluations is a function of the signal frequency. As the PolyBLEP function is stateless, the mathematical correctness of the implementation would be intact even as the function would be only conditionally evaluated.

\begin{table}[h]
 \begin{center}
\begin{tabular}{|l|l|l|l|}

      \hline
      Frequency & (A)        &  (B)         & (C) \\
      \hline\hline
      5kHz     & 352 800     & 44 100       & 10 000\\
      1kHz     & 352 800     & 44 100       &  2 000\\
      500Hz    & 352 800     & 44 100       &  1 000\\
      \hline

\end{tabular}
\caption{Amount of PolyBLEP calculations per second for a square wave at Fs = 44.1kHz. 
(A) an implementation where per each frame the PolyBLEP is evaluated for both the previous and current sample for both discontinuities. The branched nature of the residual function multiplies this number further by a factor of two.
(B) an ideal implementation without branching where only one PolyBLEP is evaluated per frame.
(C) is the number of required PolyBLEP calculations.  }\label{table:polyblep-amount}
 \end{center}
\end{table}

To be able to run this emulation in real time, I had to implement a true branching solution using an external C++ function. This is however easy to integrate with the Faust processing as the \emph{ffunction} operator lets one use externals just as native functions.

The filter bank in the real organ consists of three neary identical circuits with slightly different capacitor values. These filters are emulated by a straightforward bank of digital RC filters.

%% TODO
INSERT FULL BANDWIDTH FFT MEASUREMENTS HERE.

\subsection{Oscillator bias}
\label{section:oscillator-bias}

Every oscillator naturally produces a square wave at a different frequency. However all oscillators share a single bias voltage. This bias voltage is controlled by the vibrato circuit, touch vibrato and the master pitch potentiometer. The master pitch potentiometer is emulated with a simple slider widget with a DC output. Touch vibrato is controlled by horizontal movement of the keys. As such MIDI keyboards are rare\footnote{The only keyboard I found claiming such capability is the Yamaha STAGEA ELS-01C, which is itself a digital organ.} this feature was left out of the emulation.

Vibrato control voltage is created by a sine wave oscillator. The vibrato speed controls the speed of this oscillator. The vibrato speed range, which was simply measured from the real device, is 5-8Hz. The vibrato depth is simply an attenuation control for the vibrato oscillator output.

%% TODO. I am here!
However, measurements of the real oscillators suggest that the oscillators are modulation by a relatively low frequency source. Image XX shows a measurement of one secion I voice from the real organ (A). The measurement is centered on the fundamental and does not show the harmonics. Alongside the fundamental are two XXXX peaks at -YYYdB. The the emulated secion I voice without modulation is shown as (B) and the modulated oscillator (C). The modulation is emulated by mixing a rectified 50Hz sine wave to the oscillator bias.
%% TODO: (C) not done yet!

%% TODO
INSERT FFT PLOTS HIGHLIGHTING FUNDAMENTALS AND FREQ MODULATION


\subsection{Keyboard matrix mixer}

The keyboard matrix mixing, while a relatively simple part, contains many separate operations. Each key is a Faust button\footnote{Button output signal is 1 when the it is being pressed down and otherwise 0.} connecting multiple voices to different bus bars. This means each key button used as a multiplier for 7 different voices (one for bus bar). There is also added logic for the bass manual where the resulting downmixes from the 17 bottom keys are fed to either the main bus bars or the bass bus bars.

In procedural languages, the matrix mixer could be efficiently written as a set of floating point tables multiplied together. In Faust however, there is no such group operation. This results in a large number of separate multiplications which are difficult for the Faust compiler to optimize.

Engaging and disengaging keys is not declicked (or bandlimited). The key switches on the real organ are just simple switches connecting voices to bus bars. This operation causes clicks as switches open and close mid-wave. I have found the non-declicked sound of the emulation to match the original surprisingly well. This is something that could be looked at at a later stage.

Writing the keyboard matrix mixer also revealed an issue with the service manual. The service manual indicates wrong which voices are mixed in the harmonic bus bars (2-2/3' and 1-3/5'). The manual states that 2-2/3' is connected to a voice five semitones higher than the voice connected to 4' and 1-3/5' with a voice eight semitones higher than 2'. The real organ and, and thus the emulation, connects seven and and three semitones respectively.

% lacks semantics for this..

\subsection{Section I}
\label{section:section-I}
Section I is just an unfiltered mix of bus bars mixed together through the drawbar potentiometers and additional resistors. Thus it requires only to emulate the drawbar potentiometer taper. The taper was measured from the real organ by playing a stable note with all drawbars off except one drawbar which tested all three positions. Compared to full volume, the two middle positions were measured at -12dB and -18dB.

This can be translated into a continuous transfer function (see equation \ref{eq:levertransfer}). \emph{p} is the position of the lever from 0 (off) to 1 (fully engaged). The function returns a gain coefficient usable in the simulation. The function roughly emulates the taper and can be usad with the slider controls. Further work on a graphical user interface could provide the four position levers.

\begin{equation}
\label{eq:levertransfer}
\mbox{coeff}(p) = 2.81 x^3 - 2.81 x^2 + x
\end{equation}

%\mbox{where }p\mbox{ is lever position from 0 (off) to 1}

% TODO: this hasn't been implemented yet

\subsection{Section II}

As described earlier in section \ref{section:sections}, Section II has controllabel brightness. This is achieved through dividing each bus bar into highpassed and lowpassed streams. These streams are then mixed together into bright and dull streams. The brightness control is a simple balance mix of the two streams. The original organ has a slight -3dB dip at the center of the control which is not emulated as it reduces the use center positions dramatically.

INSERT FILTERING ONCE IT'S DONE

The section II drawbar levers are emulated as described in section \ref{section:section-I}.

% Brightness

\section{Performance}

GCC flags.

Faust flags. Especially SMP flags.

How to measure?

\section{Conclusions}

Blah blah.


\subsection{Benefits of Faust}

Functional thinking suits audio very well.

No stupid typical procedural bugs.

Transfer of huge amounts of data trivial

Readability!

Reuse!

SVG is a good learning / debugging tool.


\subsection{Things Faust needs improvement in}

Branchless select2 and select3 can very efficient in some cases, but sometimes true branches are required.

Documentation on the more advanced functions could be a lot better: recursion, rdtable, rwtable.

Compiler error messages.

DFT and inverse DFT. (I want better band-limiting.)

Size of created code: often used functions are rewritten leading to slow compilation and huge amounts of local variables.

\section{Acknowledgements}

Thanks to Petri Junno for all the help with analyzing the original organ. I would also like to thank Torben Hohn, Sakari Bergen for providing support and answering my sometimes naive questions. %Also thanks to Yann Orlarey for helpful com

% Yann

\bibliographystyle{acl}
\bibliography{lac2010_faust_in_action}

\end{document}
