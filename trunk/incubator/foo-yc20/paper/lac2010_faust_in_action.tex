\documentclass[11pt,a4paper]{article}
\usepackage{lac2010}
\usepackage{amssymb,amsmath}

\usepackage{listings}

\sloppy
\newenvironment{contentsmall}{\small}

\title{Faust in Action}

%see lac2010.sty for how to format multiple authors!
\author
{Sampo Savolainen % SAVOLAINEN?
\\ Foo-plugins
\\ http://foo-plugins.googlecode.com/
\\ sampo.savolainen@gmail.com
}

\begin{document}
\lstset{captionpos=b,tabsize=2,basicstyle=\footnotesize}

\maketitle


\begin{abstract}
\begin{contentsmall}
This paper describes the working principles of a 40 year old transistor organ and how it is emulated with software. The emulation presented in this paper is open source and written in a functional language called Faust. The architecture of the organ proved to be challenging for Faust, thus the process of writing this emulation highlighted some of Faust's strengths and shortcomings.

\end{contentsmall}
\end{abstract}

\keywords{
\begin{contentsmall}
Faust, LV2, DSP, emulation
\end{contentsmall}
}

\section{Introduction}

Faust\cite{orlarey:09c} stands for Functional AUdio STream and as the name implies it is a functional language designed for audio processing. The Faust compiler is an intermediary compiler, which produces a C++ class which is integrated into a chosen C++ "architecture". This architecture file provides a run-time environment, or wrapper, for the processing. This wrapper can be a stand-alone Linux Jack application, a LADSPA plugin or a VST plugin.

%% TODO choose license
This paper describes how an emulation of a 1970's combo-organ was written in Faust. The Yamaha YC-20 is a fairly typical organ of its time, a transistor based relatively light instrument meant for gigging musicians. The organ can be classified as a paraphonic synthesizer. Its working principles are discussed in detail in section \ref{section:yc-20}. The emulation is written as open source as GPLv3. In the spirit of open source, the working principles and decisions taken during writing the emulation are described in this paper for all to read.

The YC-20 was chosen to be emulated as its architecture is very different from typical software and virtual analog synthesizers. Instead of the complex controllability and routability of typical synthesizers, the paraphonic organ requires a large number of parallel processes and components. This makes for a good test of Fausts performance and parallelization capabilities. Access to an operational organ was also a factor in the choice, as it made possible to match the emulation quality against the original. 

\section{YC-20}
\label{section:yc-20}

This section covers the operations of the organ in detail\cite{yamaha:yc20}. This is section is later referred to when discussing the emulated parts.

\subsection{Features}

The organ has one physical manual with 61 keys and two sound sections and a switchable bass manual. Instead of drawbars like Hammond organs, the sounds are controlled by a lever system used in Yamaha organs of the time. As the word drawbar is commonplace when discussing organ sounds, I use it instead of lever. Each of the drawbar lever in the organ have four positions from off to full volume. 

Section I has drawbars 16', 8', 4', 2-2/3', 2', 1-3/5' and 1' and section II has drawbars 16', 8', 4', 2' and a continuous brightness lever. The sections can be selected or mixed together using a continuous balance lever. Enabling the bass manual switches the lowest 17 keys (white on black) to bass sounds with drawbars 16' and 8'. There are also controls for pitch, volume, bass volume, vibrato depth, vibrato speed and an obscure "touch vibrato" feature. The organ also has a single global percussion drawbar and an integrated volume pedal. Like the drawbars, all vibrato controls have four positions.

% the style of controls? .. probably irrelevant
\subsection{Tone generation}

The synthesizer architecture comprises of 12 oscillators, one per each note on an octave. For each oscillator, there are 7 frequency divider stages so each oscillator produces 8 voices totalling 96 voices. These voices are then fed through a passive filter bank. The divided voices have both a high pass and low pass filters while the oscillator voices have only a high pass filter. This totals 180 resistor-capacitor networks. Filtered voices are connected to switches controlled by the keyboard. The keyboard is in fact a matrix mixer connecting the voices to bus bars. Keys feed each bus bar with the appropriate voice matching that key and octave or the matching harmonic voice for the 2-2/3' and 1-3/5' drawbars. 

\subsection{Sections}
\label{section:sections}

The drawbars are potentiometers which control how much of each bus bar is mixed the sections of the organ. While in section I, drawbars are simply mixed together, Section II drawbars have more complex filtering. Each section II drawbar is divided into two streams, each filtered separately with rc networks. One stream is low pass filtered with two stages while the other has two stages of high pass filtering. The low passed and high passed signals from different drawbars are then combined and buffered. The brightness potentiometer controls a mix of the two which, after further buffering, is the output of section II. 

The switches on the lowest 17 keys feed either the main bus bars or separate bass bus bars. This is controlled by the bass manual switch. When disabled, the bass bus bars contain no signal. When enabled, the bass keys have no effect on the main bus bars.

Bass manual differs from the two main sections in that both bass manual drawbars (16' and 8') contain a mix of multiple bass bus bars. The 16' drawbar contains a mix of all three bass bus bars, with the 16' bass bus bar mixed with the lowest value resistor and the 4' bass bus bar with the highest value resistor. The 8' drawbar is a mix of the 8' bass bus bar with a lower value resistor and 4' bass bus bar with a higher value resistor. While section I and section II drawbar control potentiometers are wired in a standard volume configuration, the bass manual drawbars are wired center-tap to source. This configuration makes the drawbar control not only affect how much of the drawbar is mixed in, but it varies the impedance of the signal. The varying impedance and capacitor after summing the drawbar signals makes the network into a fairly complex rc filter with a varying cutoff point and mix amount per bass bus bar.

\subsection{Percussion}

% Still a bit iffy
Percussion manual sounds are created by mixing together bus bars 1', 2-2/3' and 16' via resistors. There is a substantially larger resistor on the 1' bus bar. This sum is then ran through a VCA controlled by a simple envelope generator. This envelope generator is triggered by activity on the 1' bus bar. The envelope attack and release timings are very fast while the sustain level is near zero. This causes a fast attack sound, but the effect only works when no keys are pressed down before. In other words, the percussion effect is not heard, for example, when playing legato. However there is a substantial amount of bleed from the percussion section which is audible when all other drawbars are off.

% As the bass manual switch disengages bass keys from the main bus bars

\subsection{Main output}

The main output of the device is a mix of sections I and II, the percussion part and the bass manual. The mix between sectioions I and II is controlled by the balance potentiometer. The amount of percussion mixed in is controlled by the percussion drawbar. Bass manual is summed into the main output via a potentiometer controlling its volume. This main output is preamplified and then can be attenuated by both the main volume potentiometer of the device and the volume pedal. The volume pedla works by a mechanical shutter and a light dependent resistor.

\section{The emulation} 

I chose Faust to emulate the organ as the organ is effectively an "always on" design. Unlike with polyphonic synthesizers, all possible voices of the organ are always running. There is a large amount of streams transferred between the circuits and Faust's modus operandi fits this design well. The emulation tries not only to emulate the ideal circuit but also some of the inaccuracies and issues caused in the real instrument. 

The emphasis was on creating a playable instrument which sounds as close to the original as possible. A playable emulation needs to be able to work at low latencies and it needs to be efficient enough to be ran on fairly typical hardware.

\subsection{Tone generation}
\label{section:tone-generation}

The 12 oscillators are sawtooth oscillators with a varying bias voltage (see section \ref{section:oscillator-bias}). The main oscillator sounds are divided by an array of flip flops each dividing the frequency by half. The flip flops naturally produce square waves. This means each oscillator creates 8 phase-synchronized voices.

As the main oscillator frequencies are high (4--8kHz), a naive oscillator implementation would suffer massively from aliasing at typical sampling rates (44.1--96kHz). Naturally, also the dividers need to be band-limited as well. I evaluated different methods to band-limit the signals and chose the PolyBLEP\cite{antialiasing} method. While BLEP\cite{hardsync} would produce a less aliasing harmonics, it is computationally more expensive. More importantly, the BLEP response is currently impossible to calculate in Faust as it requires DFT and inverse-DFT functions. The quality of BLIT-SWS\cite{blit} is good at high frequencies, but it produces sub-harmonics\cite{antialiasing}. Also, BLIT-SWS is problematic when it comes to synchronized oscillators\cite{hardsync}.

I evaluated second, third and fourth order polynomial functions for the PolyBLEP. The higher order residual functions reduced high frequency aliasing only slightly compared to the second order function. Furthermore the second order function did not create the sub-harmonics the third and fourth order functions caused. This confirmed previous findings\cite{pekonen}. The chosen second order polynomial residual function \emph{r(t)} is shown as equation \ref{eq:polyblep}.

\begin{equation}
\label{eq:polyblep}
r(t) = \begin{cases} 	t^2/2  + t + 1/2, & \mbox{if } -1 \leq t \leq 0\\ 
			-t^2/2 + t - 1/2, & \mbox{if } 0 < t \leq 1 \end{cases}
\end{equation}

The divider circuits emulated as slaved oscillators. The main oscillator function outputs both the signal and phase information. One divisor function divides the phase and feeds this to a slave oscillator. The slave again produces both a signal and phase information. The divider circuit for one oscillator is seven such divisor functions piggybacked.

PolyBLEP works by adding the polynomial band-limited step function to two samples: the sample before and after a discontinuity in the signal. To achieve this, the Faust implementation delays its output by one sample. At each frame, the phase is inspected and if it has passed a discontinuity, the PolyBLEP function is calculated and added (rising wave) or subtracted (falling wave) for the previous sample and the current sample. As Faust lacks true branches, all possible branches of conditional statements are always calculated. Table \ref{table:polyblep-amount} shows that branching would allow an efficient solution. This is because without branching the amount of PolyBLEP evaluations is purely a function of the sampling rate while the amount of required evaluations is a function of the signal frequency. As the PolyBLEP function is stateless, the mathematical correctness of the implementation would be intact even as the function would be only conditionally evaluated.

\begin{table}[h]
 \begin{center}
\begin{tabular}{|l|l|l|l|}

      \hline
      Frequency & (A)        &  (B)         & (C) \\
      \hline\hline
      5kHz     & 352 800     & 44 100       & 10 000\\
      1kHz     & 352 800     & 44 100       &  2 000\\
      500Hz    & 352 800     & 44 100       &  1 000\\
      \hline

\end{tabular}
\caption{Amount of PolyBLEP calculations per second for a square wave at Fs = 44.1kHz. 
(A) an implementation where per each frame the PolyBLEP is evaluated for both the previous and current sample for both discontinuities. The branched nature of the residual function multiplies this number further by a factor of two.
(B) an ideal implementation without branching where only one PolyBLEP is evaluated per frame.
(C) is the number of required PolyBLEP calculations.  }\label{table:polyblep-amount}
 \end{center}
\end{table}

To be able to run this emulation in real time, I had to implement a true branching solution using an external C++ function. This is however easy to integrate with the Faust processing as the \emph{ffunction} operator lets one use externals just as native functions.

The filter bank in the real organ consists of three neary identical circuits with slightly different capacitor values. These filters are emulated by a straightforward bank of digital RC filters.

% TODO: the filter is too steep

\emph{This section is unfinished as the filters are still being analyzed and emulated}

%% TODO: filtering is still not ok. emulation seems steeper than the real thing
INSERT FULL BANDWIDTH FFT MEASUREMENTS HERE.

\subsection{Oscillator bias}
\label{section:oscillator-bias}

Every oscillator naturally produces a square wave at a different frequency. However all oscillators share a single bias voltage. This bias voltage is controlled by the vibrato circuit, touch vibrato and the master pitch potentiometer. The master pitch potentiometer is emulated with a simple slider widget with a DC output. Touch vibrato is controlled by horizontal movement of the keys. As such MIDI keyboards are rare\footnote{The only keyboard I found claiming such capability is the Yamaha STAGEA ELS-01C, which is itself a digital organ.} this feature was left out of the emulation.

Vibrato control voltage is created by a sine wave oscillator. The vibrato speed controls the speed of this oscillator. The vibrato speed range, which was simply measured from the real device, is 5-8Hz. The vibrato depth is simply an attenuation control for the vibrato oscillator output.

%% TODO. I am here!
%However, measurements of the real oscillators suggest that the oscillators are modulation by a relatively low frequency source. Image XX shows a measurement of one secion I voice from the real organ (A). The measurement is centered on the fundamental and does not show the harmonics. Alongside the fundamental are two XXXX peaks at -YYYdB. The the emulated secion I voice without modulation is shown as (B) and the modulated oscillator (C). The modulation is emulated by mixing a rectified 50Hz sine wave to the oscillator bias.
%% TODO: (C) not done yet!

%% TODO
%INSERT FFT PLOTS HIGHLIGHTING FUNDAMENTALS AND FREQ MODULATION


\subsection{Keyboard matrix mixer}

The keyboard matrix mixing, while a relatively simple part, contains many separate operations. Each key is a Faust button\footnote{Button output signal is 1 when the it is being pressed down and otherwise 0.} connecting multiple voices to different bus bars. This means each key button used as a multiplier for 7 different voices (one per bus bar). There is also added logic for the bass manual where the resulting downmixes from the 17 bottom keys are fed to either the main bus bars or the bass bus bars.

In procedural languages, the matrix mixer could be efficiently written as a set of floating point tables multiplied together. In Faust however, there is no such group operation. This results in a large number of separate multiplications which are difficult for the Faust compiler to optimize.

Engaging and disengaging keys is not declicked (or band-limited). The key switches on the real organ are just simple switches connecting voices to bus bars. This operation causes clicks as switches open and close mid-wave. I have found the non-declicked sound of the emulation to match the original surprisingly well. This is something that could be looked at at a later stage.

Writing the keyboard matrix mixer also revealed an issue with the service manual. The service manual indicates wrong which voices are mixed in the harmonic bus bars (2-2/3' and 1-3/5'). The manual states that 2-2/3' is connected to a voice five semitones higher than the voice connected to 4' and 1-3/5' with a voice eight semitones higher than 2'. The real organ and, and thus the emulation, connects seven and and three semitones respectively.

% lacks semantics for this..

\subsection{Section I}
\label{section:section-I}

Section I is just an unfiltered mix of bus bars mixed together through the drawbar potentiometers and additional resistors. Thus it requires only to emulate the drawbar potentiometer taper. The taper was measured from the real organ by playing a stable note with all drawbars off except one drawbar which tested all three positions. Compared to full volume, the two middle positions were measured at -12dB and -18dB.

This can be translated into a continuous transfer function (see equation \ref{eq:levertransfer}). \emph{p} is the position of the lever from 0 (off) to 1 (fully engaged). The function returns a gain coefficient usable in the emulation. The function roughly emulates the taper and can be usad with the slider controls. Further work on a graphical user interface could provide the four position levers.


\begin{equation}
\label{eq:levertransfer}
\begin{split}
\mbox{coeff}(p) &= 2.81 p^3 - 2.81 p^2 + p \\
\mbox{coeff}(0) &= -\mbox{inf} \mbox{ dB}\\
\mbox{coeff}(1/3) &\approx -18.05 \mbox{ dB}\\
\mbox{coeff}(2/3) &\approx -12.03 \mbox{ dB}\\
\mbox{coeff}(1) &= +0.00 \mbox{ dB}
\end{split}
%\mbox{where }p\mbox{ is lever position from 0 (off) to 1}
\end{equation}


% TODO: this hasn't been implemented yet

\subsection{Section II}

As described earlier in section \ref{section:sections}, Section II has controllable brightness. This is achieved through dividing each bus bar into two streams which are high-passed and low-passed separately. The streams derived from different bus bars are then mixed together into bright and dull streams. The brightness control is a simple balance control between the two streams. The original organ has a slight -3dB dip at the center of the control which is not emulated as it reduces the use of center positions dramatically.

\emph{This section is unfinished as the filters are still being analyzed and emulated}

% TODO:
The high pass filtering is done by a two stage rc filter with a resistor in parallel to the capacitor in the first filter. This makes the filter act as a shelfing high pass filter. The lowpass section is simply a two stage lowpass rc filter.

% TODO:

INSERT SPECTRUM ANALYSIS OF SECTION II VOICES (REAL AND EMULATED) ONCE IT'S DONE

The section II drawbar levers are emulated as described in section \ref{section:section-I}.

\section{Performance}
\label{section:performance}

Running this paraphonic synthesizer requires a much processing power. There are 96 oscillators working all of the time and there are hundreds of filters being applied at many stages of the design. The design can be parallelized easily and as such, it should work as a good real world test for Fausts SMP features.

The performance numbers shown here are measured using a modified version of the faust benchmarking suite. These numbers are estimates of achieved memory bandwidth and as such, the results are bytes of audio data generated per second. The Faust benchmark uses this measurement as memory bandwidth on SMP systems is a precious commodity. In the case of the YC-20, the processing creates much more data than what is mixed into the output. Thus the figures can be only be really compared to each other.

Tests were ran on a Dell D820 laptop with a Core 2 Duo T7400 (2.16Ghz) processor using the internal soundcard. The operating system was 32 bit Ubuntu 9.10. Processor frequency governor was switched to performance on both cores before running the tests. The kernel was a standard Ubuntu package, 2.6.31-19-generic and the used gcc version was 4.4.1-4ubuntu9. Benchmarks were done one YC-20 code revision 227. (C) shows the impact of non-branching PolyBLEP calculations and is compiled with slight modifications to the same revision. The results are shown in table \ref{table:performance}.

\begin{table}[h]
 \begin{center}
\begin{tabular}{|l|l|l|l|}

      \hline
      Tests (MB/s)             & (A)  & (B)  & (C) \\
      \hline\hline
      scalar (galsascal)       & 0.40 & 0.43 & 0.28 \\
      vectorized (galsavec)    & 0.58 & 0.59 & 0.35 \\
      vectorized 2 (galsavec2) & 0.62 & 0.62 & 0.34 \\
      OpenMP (galsomp2)        & 0.51 & 0.55 & 0.29 \\
      scheduler (galsasch)     & 0.90 & 0.88 & N/A \\
      scheduler 2 (galsasch2)  & 0.93 & 0.89 & N/A \\
      \hline

\end{tabular}
\caption{The tests were ran with different sets of gcc parameters: \\
(A) Branching C++ PolyBLEP evaluations. gcc -O3 -march=native -mfpmath=sse -msse -msse2 -msse3 -ffast-math -ftree-vectorize \\
(B) Branching C++ PolyBLEP evaluations. gcc -O3 -march=native -mfpmath=sse -msse -msse2 -msse3 -ffast-math -ftree-vectorize -fgcse-sm  -funsafe-math-optimizations \\
(C) Divider slave oscillators use non-branched PolyBLEP operations. gcc -O3 -march=native -mfpmath=sse -msse -msse2 -msse3 -ffast-math -ftree-vectorize -fgcse-sm  -funsafe-math-optimizations \\
GCC was unable to compile the scheduler versions of the emulation with non-branching PolyBLEP operations.\\
}\label{table:performance}
 \end{center}
\end{table}

There was variance between consecutive test runs, so the only real results deductable from the tests shown in table \ref{table:performance} is that the scheduler mode seemed to give the best performance. However this data is backed by tests done by measuring the performance of the YC-20 emulation running as a real jack application. The measurements shown in table \ref{table:performance2} were done by running the emulation compiled with different flags and observing the DSP percentage meter in qjackctl. This meter tells how much of the time between jack engine callbacks is spent processing jack signal callbacks.

\begin{table}[h]
 \begin{center}
\begin{tabular}{|l|l|l|}

      \hline
      Tests         & Faust flags & Load   \\
      \hline\hline
      scalar        & none & $\sim$ 49\% \\
      vectorized    & -vec -vs 32 & $\sim$ 34\% \\
      scheduler     & -sch -g -vs 256 & $\sim$ 29\% \\
      \hline

\end{tabular}
\caption{All tests were compiled with the following gcc flags: \\
-O3 -march=native -mfpmath=sse -msse -msse2 -msse3 -ffast-math -ftree-vectorize. Jack was running realtime with a dummy backend simulating a 48kHz sample rate with 512 frame buffers.
}\label{table:performance2}
 \end{center}
\end{table}



\section{Conclusions}

While there is still some way to go for an accurate emulation of the YC-20, this work has created a usable combo-organ synthesizer which sounds very much like the real YC-20.  The remaining work is mostly meticulous filter tuning. A better quality anti-aliasing method could be useful although the available methods will come at the expense of even more CPU cycles. The real organ also has considerable bleed and inconsitencies which might be worth emulating.

\subsection{Benefits of Faust}

Functional thinking suits audio applications very well, as solutions to problems can often be expressed as equations. This model sidesteps many of the issues procedural programs face, as the signal flow between processors can be expressed as such. Unlike with procedural languages, Faust allows programmers to not worry about buffers, their lengths or offsets or loop structures. This also saves time as the programmer can concentrate on processing instead of debugging issues with tranferring buffers and interpreting offsets and buffer lengths.

In addition to the previously mentioned benefits, the created code is also more readable. The syntax offers good tools, such as sequential composition, which keep functions simple and concise. This is often beneficial when compared to typical C-style syntax where one needs to use with consecutive function calls or enclosed statements. See listings \ref{list:c-consec}, \ref{list:c-enclosed} and \ref{list:faust} for an example. While listing \ref{list:c-enclosed} is pretty readable, one should note that functions are presented to the reader in reverse order and it is also difficult to see to which function the multiplication is applied to.

\begin{lstlisting}[language=C,label=list:c-consec,caption=Consecutive calls]
float dostuff(float f) {
	f = func1(f);
	f = func2(f) * 2.5;
	f = func3(f);
	return f;
}
\end{lstlisting}

\begin{lstlisting}[language=C,label=list:c-enclosed,caption=Enclosed statements]
float dostuff(float f) {
	return func3( func2( func1(f)) * 2.5 );
}
\end{lstlisting}

\begin{lstlisting}[language=C,label=list:faust,caption=Faust sequential composition]
dostuff = func1 : func2 : *(2.5) : func3;
\end{lstlisting}

The SVG output of the Faust compiler is also worth mentioning. The compiler can create a hyperlinked SVG document which depicts the whole compiled process function. This document can be an excellent learning and debugging tool as it shows how the compiler understood the compiled code.

The stream concept also makes code reusable. When combining procedural code from multiple parties you often need to either convert data types between the different modules or refactor the modules to match. Faust processors naturally fit with each other. This model works very well with open source as it can promote the spread of good ideas and implementations. It might even lead to a resource library of truly reusable components usable with any Faust project -- as long as the licenses are compatible.

Faust also allows automatic parallelization and vectorization of programs. This allows access to these advanced optimization methods which usually require expert programming skills to implement. These capabilities have been discussed in detail by Orlarey, Fober and Letz\cite{orlarey:09a}.

\subsection{Improvements to Faust}

As discussed in section \ref{section:tone-generation} and shown in the results in section \ref{section:performance}, there is a strong case for a truly branching select operation. However, the semantics of Faust requires all of the processing graph to be evaluated for every frame. But the semantics are kept intact if the function or functions truly branching select clauses skip evaluating are stateless. This is because the next evaluation of the function does not depend on previous evaluations. This leaves the Faust with a choice: either select calls with stateless functions as parameters are compiled as truly branching automatically or a new branching select call is created. Both cases require the specification of rules on what a stateless function is. Also, the compiler must check whether the functions being skipped over comply to these specifications before allowing compilation of such code.

This logic could also be applied to functions using comparison operators in equations. Equation \ref{eq:comp-op} is an example of a function where the second (stateless) part of the first multiplication could be optimized out for values x less or equal to 0 as in those cases, the first part would be 0.

\begin{equation}
\label{eq:comp-op}
f(x) = (x>0) * (x^2-fmod(x,1.0))
\end{equation}

%Branchless select2 and select3 can very efficient in some cases, but sometimes true branches are required.

The compiler error messages are often unhelpful. They do not always even specify in which file the compilation error occurred. Optimally the compiler should identify the file name, line number and if possible, the name of the function the error occurred in. One specific issue with the compiler messages is worth giving special attention. It is cases where the inputs and outputs of functions in a sequential composition do not match. In such cases Faust outputs a quite exhausting description of the functions in the compisition, instead of just the names of the functions. For example, if the YC-20 emulation would fail to cut the phase output of the last divider (dividers would then output 108 instead of 96 streams), the resulting error message is 67 kilobytes.

In the audio world, lack of support for fourier transforms is very unfortunate. As mentioned in section \ref{section:tone-generation}, the better band limiting method (BLEP) is not possible to implement in pure faust. Fourier transforms would naturally be useful for a variety of other tasks as well. Fortunately there has been promising news of multi rate support for Faust which would allow fourier transforms.

As procedural programming is the prevailing model of programming, it is safe to say many potential users of Faust are familiar with only that model. This applies some pressure to good documentation. The current documentation should abbreviate the definitions of the more advanced features of the language. Mainly recursion and the rdtable and rwtable functions could benefit from better explanations. Currently the functions are almost side-stepped and only their function syntax is given.

Implementing the matrix mixer required a lot of hand-crafting. Having a concept of indexable arrays would help such operations. If the 96 inputs of the keyboard mixer and the buttons representing the keys of the organ could be arranged into arrays, the mixing could be done algorithmically using the sum aggregate function. Such operations could surely open up possibilities of optimizing the created C++ code. As it stands, the keyboard mixing is compiled into a large amount of separate discrete multiplication and addition operations.

% DSP processors?

%Size of created code: often used functions are rewritten leading to slow compilation and huge amounts of local variables.

\section{Acknowledgements}

Thanks to Petri Junno for all the help with analyzing the original organ. I would also like to thank Torben Hohn, Sakari Bergen for providing support and answering my sometimes naive questions. %Also thanks to Yann Orlarey for helpful com

% Yann

\bibliographystyle{acl}
\bibliography{lac2010_faust_in_action}

\end{document}
